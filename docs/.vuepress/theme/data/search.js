export default [
  {
    "title": "Css布局",
    "path": "/Posts/CSS/layout.html",
    "strippedContent": " ### 单栏布局  #### 示例 1  <p class=\"codepen\" data-height=\"265\" data-theme-id=\"light\" data-default-tab=\"html,result\" data-user=\"lwwtotod\" data-slug-hash=\"PgRzQx\" style=\"height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;\" data-pen-title=\"单栏布局\">   <span>See the Pen <a href=\"https://codepen.io/lwwtotod/pen/PgRzQx/\">   单栏布局</a> by lwwtotod (<a href=\"https://codepen.io/lwwtotod\">@lwwtotod</a>)   on <a href=\"https://codepen.io\">CodePen</a>.</span> </p> <script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>  #### 示例 2(通栏)  <p class=\"codepen\" data-height=\"265\" data-theme-id=\"light\" data-default-tab=\"html,result\" data-user=\"lwwtotod\" data-slug-hash=\"wZmWjZ\" style=\"height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;\" data-pen-title=\"单栏布局2\">   <span>See the Pen <a href=\"https://codepen.io/lwwtotod/pen/wZmWjZ/\">   单栏布局2</a> by lwwtotod (<a href=\"https://codepen.io/lwwtotod\">@lwwtotod</a>)   on <a href=\"https://codepen.io\">CodePen</a>.</span> </p> <script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>  ### 两栏布局  #### 示例 1  <p class=\"codepen\" data-height=\"265\" data-theme-id=\"light\" data-default-tab=\"html,result\" data-user=\"lwwtotod\" data-slug-hash=\"pBLbPz\" style=\"height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;\" data-pen-title=\"两栏布局\">   <span>See the Pen <a href=\"https://codepen.io/lwwtotod/pen/pBLbPz/\">   两栏布局</a> by lwwtotod (<a href=\"https://codepen.io/lwwtotod\">@lwwtotod</a>)   on <a href=\"https://codepen.io\">CodePen</a>.</span> </p> <script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>  #### 示例 2  <p class=\"codepen\" data-height=\"265\" data-theme-id=\"light\" data-default-tab=\"html,result\" data-user=\"lwwtotod\" data-slug-hash=\"GLxqvB\" style=\"height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;\" data-pen-title=\"两栏布局2\">   <span>See the Pen <a href=\"https://codepen.io/lwwtotod/pen/GLxqvB/\">   两栏布局2</a> by lwwtotod (<a href=\"https://codepen.io/lwwtotod\">@lwwtotod</a>)   on <a href=\"https://codepen.io\">CodePen</a>.</span> </p> <script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>  #### 示例 3  <p class=\"codepen\" data-height=\"265\" data-theme-id=\"light\" data-default-tab=\"html,result\" data-user=\"lwwtotod\" data-slug-hash=\"NmYrwm\" style=\"height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;\" data-pen-title=\"两栏布局3\">   <span>See the Pen <a href=\"https://codepen.io/lwwtotod/pen/NmYrwm/\">   两栏布局3</a> by lwwtotod (<a href=\"https://codepen.io/lwwtotod\">@lwwtotod</a>)   on <a href=\"https://codepen.io\">CodePen</a>.</span> </p> <script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>  ### 三栏布局  #### 双飞翼布局  <p class=\"codepen\" data-height=\"265\" data-theme-id=\"light\" data-default-tab=\"html\" data-user=\"lwwtotod\" data-slug-hash=\"ROxGMa\" style=\"height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;\" data-pen-title=\"双飞翼布局\">   <span>See the Pen <a href=\"https://codepen.io/lwwtotod/pen/ROxGMa/\">   双飞翼布局</a> by lwwtotod (<a href=\"https://codepen.io/lwwtotod\">@lwwtotod</a>)   on <a href=\"https://codepen.io\">CodePen</a>.</span> </p> <script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>  #### 圣杯布局  <p class=\"codepen\" data-height=\"265\" data-theme-id=\"light\" data-default-tab=\"html,result\" data-user=\"lwwtotod\" data-slug-hash=\"YMaWJv\" style=\"height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;\" data-pen-title=\"三栏布局2\">   <span>See the Pen <a href=\"https://codepen.io/lwwtotod/pen/YMaWJv/\">   三栏布局2</a> by lwwtotod (<a href=\"https://codepen.io/lwwtotod\">@lwwtotod</a>)   on <a href=\"https://codepen.io\">CodePen</a>.</span> </p> <script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script> "
  },
  {
    "title": "javascript题目",
    "path": "/Posts/InterView/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html",
    "strippedContent": " # javascript题目    ## HTML    ### <img>的 title 和 alt 有什么区别？    alt 主要是无法加载显示图片时，代替文字，搜索引擎时主要是 `alt`，`alt` 只适用于图片 img。 鼠标悬浮文字上显示文字的诗 `title` 属性，`title` 适用于很多标签。    ### 什么是 web 语义化？html5 有哪些语义化标签？语义化有什么好处？    W3C 组织意识到了之前 HTML 版本的不足，推出的 HTML5 进一步推进了 Web 语义化发展，采用了诸如 footer、section 等语义化标签，弥补了采用 id=\"footer\"或者 class=\"footer\"形式的不足，以更好的推动 Web 的发展。    ```html  <nav>    、    <article>      、<sections        >、        <aside>          、          <footer></footer></aside      ></sections>    </article>  </nav>  ```    ## CSS    ### display: none;与 visibility: hidden;的区别？    是否是继承属性：display 不是继承属性，而 visibility 是继承属性。    ### 如何分别水平、垂直居中一个元素？    - 行内水平居中    ```css  #container {    text-align: center;  }  ```    - 块状水平居中    ```css  #center {    margin: 0 auto;  }  ```    - 多个块状元素的水平居中    ```css  #container {    text-align: center;  }    #center {    display: inline-block;  }  <!-- flex -- > #container {    justify-content: center;    display: flex;  }  ```    - 已知高度宽度元素的水平垂直居中    ```css  <!-- 1 -- > #container {    position: relative;  }    #center {    width: 100px;    height: 100px;    position: absolute;    top: 50%;    left: 50%;    margin: -50px 0 0 -50px;  }  <!-- 2 -- > #container {    position: relative;  }    #center {    position: absolute;    margin: auto;    top: 0;    bottom: 0;    left: 0;    right: 0;  }  ```    - 未知高度和宽度元素的水平垂直居中    ```css  <!-- base -- > #container {    display: table-cell;    text-align: center;    vertical-align: middle;  }    #center {  }  <!-- css3 -- > #container {    position: relative;  }    #center {    position: absolute;    top: 50%;    left: 50%;    transform: translate(-50%, -50%);  }  <!-- flex -- > #container {    display: flex;    justify-content: center;    align-items: center;  }    #center {  }  ```    ## JS    ### 如何实现一个 JS 对象的深度克隆？    先来说一下什么是深度克隆：深拷贝是指源对象与拷贝对象互相独立，其中任何一个对象的改动都不会对另外一个对象造成影响。 举个例子，一个人名叫张三，后来用他克隆（假设法律允许）了另外一个人，叫李四，不管是张三缺胳膊少腿还是李四缺胳膊少腿都不会影响另外一个人。    在 JavaScript 中，对于 Object 和 Array 这类引用类型值，当从一个变量向另一个变量复制引用类型值时，这个值的副本其实是一个指针，两个变量指向同一个堆对象，改变其中一个变量，另一个也会受到影响。    ```javascript  // 对象  var o1 = { a: 1 }  var o2 = o1    console.log(o1 === o2) // =>true  o2.a = 2  console.log(o1.a) // => 2    // 数组  var o1 = [1, 2, 3]  var o2 = o1    console.log(o1 === o2) // => true  o2.push(4)  console.log(o1) // => [1,2,3,4]  ```    这种拷贝分为两种情况：拷贝引用和拷贝实例，也就是我们说的浅拷贝和深拷贝    浅拷贝（shallow copy）代码实现：    ```javascript  function shallowClone(source) {    if (!source || typeof source !== 'object') {      throw new Error('error arguments')    }    var targetObj = source.constructor === Array ? [] : {}    for (var keys in source) {      if (source.hasOwnProperty(keys)) {        targetObj[keys] = source[keys]      }    }    return targetObj  }  ```    深拷贝（deep copy）  深拷贝也就是拷贝出一个新的实例，新的实例和之前的实例互不影响，深拷贝的实现有几种方法，首先我们可以借助 jQuery，lodash 等第三方库完成一个深拷贝实例。在 jQuery 中可以通过添加一个参数来实现递归 extend，调用\\$.extend(true, {}, ...)就可以实现一个深拷贝。    深拷贝（deep copy）代码实现：    ```javascript  // 递归实现一个深拷贝  function deepClone(source) {    //判断传入的参数是否是对象    if (!source || typeof source !== 'object') {      throw new Error('error arguments', 'shallowClone')    }    //  判断要深拷贝的是数组还是对象    var targetObj = source.constructor === Array ? [] : {}    //  遍历复制对象    for (var keys in source) {      if (source.hasOwnProperty(keys)) {        //  判断如果为对象的key还是对象的话就递归调用        if (source[keys] && typeof source[keys] === 'object') {          targetObj[keys] = source[keys].constructor === Array ? [] : {}          targetObj[keys] = deepClone(source[keys])        } else {          targetObj[keys] = source[keys]        }      }    }    //  返回克隆完的对象    return targetObj  }  // test example  var o1 = {    arr: [1, 2, 3],    obj: {      key: 'value'    },    func: function() {      return 1    }  }  var o3 = deepClone(o1)  console.log(o3 === o1) // => false  console.log(o3.obj === o1.obj) // => false  console.log(o2.func === o1.func) // => true  ```    > - [参考详情](https://yuchengkai.cn/docs/zh/frontend/#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D)    ### 事件冒泡    #### IE 与火狐的事件机制有什么区别？什么是事件冒泡？如何阻止冒泡？    1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为  2. 事件处理机制：IE 是事件冒泡、firefox 同时支持两种事件模型，也就是：捕获型事件和冒泡型事件  3. ev.stopPropagation();    - 注意旧 ie 的方法：ev.cancelBubble = true;    ### 在浏览器地址栏中输入一个 URL 后回车，背后会进行哪些技术步骤？    > - [参考详情](https://www.zhihu.com/question/34873227)    ### 编程实现获取 URL 中的参数：    1. 指定参数名称，返回该参数的值或者空字符串;    2. 不指定参数名称，返回全部的参数对象或者{};    3. 如果存在多个同名参数，则返回数组;    ```javascript  /**   * @param {string} Url   * @param {string} Key   * @return {Object}   */  function getUrlParam(Url, Key) {    var param = Url.split('#')[0].split('?')[1]    if (Key) {      //指定参数名称      var strs = param.split('&')      var arrs = new Array() //如果存在多个同名参数，则返回数组      for (var i = 0, len = strs.length; i < len; i++) {        var tmp = strs[i].split('=')        if (tmp[0] == Key) {          arrs.push(tmp[1])        }      }      if (arrs.length == 1) {        //返回该参数的值或者空字符串        return arrs[0]      } else if (arrs.length == 0) {        return ''      } else {        return arrs      }    } else {      //不指定参数名称，返回全部的参数对象 或者 {}      if (param == undefined || param == '') {        return {}      } else {        var strs = param.split('&')        var arrObj = new Object()        for (var i = 0, len = strs.length; i < len; i++) {          var tmp = strs[i].split('=')          if (!(tmp[0] in arrObj)) {            arrObj[tmp[0]] = []          }          arrObj[tmp[0]].push(tmp[1])        }        return arrObj      }    }  }  // testUrl  //http://www.nowcoder.com?key=1&key=2&key=3&test=4#hehe  ```    ### 输入习题    #### 以下程序输出结果是？    ```javascript  function fn(a) {    console.log(a)    var a = 2    function a() {}    console.log(a)  }  fn(1)  ```    #### 以下程序输出结果是？    ```javascript  var a = 10  a.pro = 10  console.log(a.pro + a)  var s = 'hello'  s.pro = 'world'  console.log(s.pro + s)  ```    #### 写出输出结果    ```javascript  console.log(typeof null)  console.log(typeof {})  console.log(typeof [])  console.log(typeof undefined)  ```    #### 写出输出结果？    ```javascript  function printing() {    console.log(1)    setTimeout(function() {      console.log(2)    }, 1000)    setTimeout(function() {      console.log(3)    }, 0)    console.log(4)  }  printing()  ```    ### 如何判断一个对象是否为函数？    ```javascript  function isFunction(fn) {    return Object.prototype.toString.call(fn) === '[object Function]'  }  ```    ### 写出几种 js 跳转的常见方式？    ```html  <!-- 第一种：直接跳转加参数 -->  <script language=\"javascript\" type=\"text/javascript\">          window.location.href=\"login.jsp?backurl=\"+window.location.href;  </script>  <!-- 直接跳转无参数： -->  <script>window.location.href='http://www.baidu.com';</script>  <!-- 第二种：返回上一次预览界面 -->  <script language=\"javascript\">  alert(\"返回\");  window.history.back(-1);  </script>  <!-- 标签嵌套： -->  <a href=\"javascript:history.go(-1)\">返回上一步</a>    <a href=\"<%=Request.ServerVariables(\"HTTP_REFERER\")%>\">返回上一步</a>  <!-- 第三种：指定跳转页面 对框架无效。。。 -->  <script language=\"javascript\">      window.navigate(\"top.jsp\");  </script>  <!-- 第四种：指定自身跳转页面 对框架无效。。 -->  <script language=\"JavaScript\">    self.location='top.htm';  </script>  <!-- 第五种：指定自身跳转页面 对框架有效。。 -->  <script language=\"javascript\">        alert(\"非法访问！\");        top.location='xx.aspx';  </script>  <!-- 第六种：按钮式 在button按钮添加 事件跳转。 -->  <input name=\"pclog\" type=\"button\" value=\"GO\" onClick=\"location.href='login.aspx'\">  <!-- 第七种：在新窗口打开： -->  <a href=\"javascript:\" onClick=\"window.open('login.aspx','','height=500,width=611,scrollbars=yes,status=yes')\">开新窗口</a>  ```    ### 写出客户端存储 localStorage 和 sessionStorage 的 set、get 方法，localStorage 和 sessionStorage 有何区别？    > [参考详情](https://blog.csdn.net/xiaoermingn/article/details/53178092)    ### 通过 JS 获取页面尺寸、屏幕的方法？    ```  网页可见区域宽：document.body.clientWidth  网页可见区域高：document.body.clientHeight  网页可见区域宽：document.body.offsetWidth (包括边线的宽)  网页可见区域高：document.body.offsetHeight (包括边线的宽)  网页正文全文宽：document.body.scrollWidth  网页正文全文高：document.body.scrollHeight  网页被卷去的高：document.body.scrollTop  网页被卷去的左：document.body.scrollLeft  网页正文部分上：window.screenTop  网页正文部分左：window.screenLeft  屏幕分辨率的高：window.screen.height  屏幕分辨率的宽：window.screen.width  屏幕可用工作区高度：window.screen.availHeight  屏幕可用工作区宽度：window.screen.availWidth  ```    ### 列举 JS 实现跨域的几种方式？    > [参考详情](https://juejin.im/entry/57d21eadbf22ec005f9c7d76)    ### 列举几种立即执行函数的实现方式。    > [参考详情](https://blog.csdn.net/wei_smile/article/details/77938180)    ### var numberArray = [3, 6, 2, 4, 1, 5];    1.  实现对该数组的倒排，输出[5, 1, 4, 2, 6, 3]  2.  实现对该数组的的将序排列，输出[6, 5, 4, 3, 2, 1];    ### 编写一个方法，去掉一个数组的重复元素    ```javascript  function unique(arr) {    var newArr = []    for (var i = 0, item; (item = arr[i++]); ) {      if (newArr.indexOf(item) === -1) {        newArr.push(item)      }    }    return newArr  }  ```    ### 写一个简单的 ajax 示例    > [参考详情](http://www.runoob.com/try/try.php?filename=tryajax_first)    ### JavaScript 有哪些方法定义对象？    > [参考详情](http://www.runoob.com/js/js-objects.html)    ## HTTP    ### HTTP request 报文结构是怎样的？    - 请求行: {请求方法} {资源路径} {协议版本}    - 请求头: 紧跟请求行的下一行，所有的请求头，除 Host 外都是可选的。    - 空行: 告诉服务器请求头部到此为止。    - 消息体: 消息的主体部分，消息体的数据格式通过 header 里面的 Content-Type 属性指定。    ### 描述常见的 HTTP 状态码和 HTTP 方法    - `200` - 请求成功  - `301` - 资源（网页等）被永久转移到其它 URL  - `404` - 请求的资源（网页等）不存在  - `500` - 内部服务器错误    > - [参考详情](http://www.runoob.com/http/http-status-codes.html)    根据 HTTP 标准，HTTP 请求可以使用多种请求方法。    HTTP1.0 定义了三种请求方法： `GET`, `POST` 和 `HEAD` 方法。    HTTP1.1 新增了五种请求方法：`OPTIONS`, `PUT`, `DELETE`, `TRACE` 和 `CONNECT` 方法。    | 序号 | 方法    | 描述                                                                                                                                     |  | ---- | ------- | ---------------------------------------------------------------------------------------------------------------------------------------- |  | 1    | GET     | 请求指定的页面信息，并返回实体主体。                                                                                                     |  | 2    | HEAD    | 类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头                                                                          |  | 3    | POST    | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 |  | 4    | PUT     | 从客户端向服务器传送的数据取代指定的文档的内容。                                                                                         |  | 5    | DELETE  | 请求服务器删除指定的页面。                                                                                                               |  | 6    | CONNECT | HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。                                                                                |  | 7    | OPTIONS | 允许客户端查看服务器的性能。                                                                                                             |  | 8    | TRACE   | 回显服务器收到的请求，主要用于测试或诊断。                                                                                               |    > - [参考详情](http://www.runoob.com/http/http-methods.html)    ### HTTP 状态码及其含义？    > [参考链接](https://lwwtotod.github.io/doc/InterView/%E4%B8%80%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-%E6%8F%8F%E8%BF%B0%E5%B8%B8%E8%A7%81%E7%9A%84-http-%E7%8A%B6%E6%80%81%E7%A0%81%E5%92%8C-http-%E6%96%B9%E6%B3%95)    ## Vue    ### 请简单描述 Vue 双向绑定底层实现原理，常用到的指令及 Vue 实例的生命周期    > - [参考详情](https://juejin.im/post/5abdd6f6f265da23793c4458)    ## 算法题    ### 给出两个单词 word1 和 word2，找出将 word1 转换成 word2 所使用的最少的步骤数（每个操作记为一步）。    你可以对一个单词进行以下三种操作    1. 插入一个字符;  2. 删除一个字符;  3. 替换一个字符;    ```javascript  /**   * @param {string} word1   * @param {string} word2   * @return {number}   */  var minDistance = function(word1, word2) {    var len1 = word1.length,      len2 = word2.length,      matrix = [],      i,      j      if (len1 === 0 || len2 === 0) {      return Math.max(len1, len2)    }    //initialization    for (i = 0; i <= len1; i++) {      matrix[i] = []      matrix[i][0] = i    }    for (j = 0; j <= len2; j++) {      matrix[0][j] = j    }      for (i = 1; i <= len1; i++) {      for (j = 1; j <= len2; j++) {        if (word1.charAt(i - 1) === word2.charAt(j - 1)) {          matrix[i][j] = matrix[i - 1][j - 1]        } else {          matrix[i][j] =            Math.min(matrix[i - 1][j], matrix[i][j - 1], matrix[i - 1][j - 1]) + 1        }      }    }    return matrix[len1][len2]  }  ```    ## 性能优化    ### 如何进行网站性能优化，请简述。    - 代码层面：避免使用 css 表达式，避免使用高级选择器，通配选择器。  - 缓存利用：缓存 Ajax，使用 CDN，使用外部 js 和 css 文件以便缓存，添加 Expires 头，服务端配置 Etag，减少 DNS 查找等  - 请求数量：合并样式和脚本，使用 css 图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。  - 请求带宽：压缩文件，开启 GZIP，    代码层面的优化  - 用 hash-table 来优化查找  - 少用全局变量  - 用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 javascript 性能  - 用 setTimeout 来避免页面失去响应  - 缓存 DOM 节点查找的结果  - 避免使用 CSS Expression  - 避免全局查询  - 避免使用 with(with 会创建自己的作用域，会增加作用域链长度)  - 多个变量声明合并  - 避免图片和 iFrame 等的空 Src。空 Src 会重新加载当前页面，影响速度和效率  - 尽量避免写在 HTML 标签中写 Style 属性  - 移动端性能优化  - 尽量使用 css3 动画，开启硬件加速。  - 适当使用 touch 事件代替 click 事件。  - 避免使用 css3 渐变阴影效果。  - 可以用 transform: translateZ(0) 来开启硬件加速。（见下面的详细解释）  - 不滥用 Float。Float 在渲染时计算量比较大，尽量减少使用  - 不滥用 Web 字体。Web 字体需要下载，解析，重绘当前页面，尽量减少使用。  - 合理使用 requestAnimationFrame 动画代替 setTimeout  - CSS 中的属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）会触发 GPU 渲染，请合理使用。过渡使用会引发手机过耗电增加  - PC 端的在移动端同样适用  "
  },
  {
    "title": "Mac下配置ngxin",
    "path": "/Posts/Nginx/mac%E4%B8%8B%E9%85%8D%E7%BD%AEngxin.html",
    "strippedContent": " # Mac 系统如何使用 Nginx  1. 使用 brew 安装  ```shell <!-- 更新brew--> brew update  <!-- 查看安装信息--> brew -v  <!-- 查看是否安装了nginx--> brew info nginx  ```  2. 安装 nginx  ``` brew install nginx ```  3. 启动 nginx  ``` <!--启动nginx--> nginx <!--重启nginx--> nginx -s reload <!--停止nginx--> nginx -s stop  ``` "
  },
  {
    "title": "npm 与 yarn 管理工具",
    "path": "/Posts/Nodejs/npm%E4%B8%8Eyarn.html",
    "strippedContent": " # npm 与 yarn 管理工具    全局安装 nrm 与 yrm        npm install nrm -g      &&      npm install yrm -g    查看源        nrm ls      &&      yrm ls    使用淘宝源        nrm use cnpm      &&      yrm ue cnpm  "
  },
  {
    "title": "vuepress主题配置",
    "path": "/Posts/vuepress%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE.html",
    "strippedContent": " # vuepress-theme-minimalism  ## 介绍  一款简洁的 vuepress 主题，兼容 hexo YAML front matter 语法。  ## 快速上手  - 安装  ``` npm i -S vuepress-theme-minimalism or yarn add vuepress-theme-minimalism ```  - 在 config.js 使用 theme  ```js module.exports = {   theme: 'vuepress-theme-minimalism',   base: '/',   ... } ```  - 文章写在 Posts 目录，新建 Posts 文件夹 注：区分大小写  ``` . ├─ docs │  ├─ Posts │  ├─ README.md │  └─ .vuepress │     └─ config.js └─ package.json ```  - 新建 index.md 文件,填写以下配置  ```yml --- home: true #代表首页 actionText: 开始Start reading... #首页文字 actionLink: /list #首页跳转链接 # footer: ©2020 Power by VuePress Theme minimalism ---  ``` - 书写正确格式的文章  ```  ```  ## 目录结构  ```yml . ├── docs │   ├── .vuepress #vuepress配置文件夹 │   ├── List.md #列表 │   ├── Posts #文章存放文件夹 │   ├── Tags.md #标签页 │   ├── TimeLine.md #时间线 │   └── index.md #首页 ├── package.json └── yarn.lock  ```  ## 主题配置  ```json themeConfig: {     home: true,     homeBackground: { //设置主页背景颜色，false title为默认颜色       show: true,       fileName: '/GetImage.jpeg'     },     PostsListPopover: false, //是否显示文章内容提示     darkMode: {       //暗模式配置       switch: true, //开关       auto: false, //自动开启       on: '', //时间       off: ''     },     vssue: { //评论插件配置       option: {         owner: '你的github账户名',         repo: '你的仓库名',         clientId: '你的clientId',         clientSecret: '你的clientSecret' // 只有在使用某些平台时需要       }     }   } ``` "
  },
  {
    "title": "mac下修改hosts文件",
    "path": "/Posts/Terminal/mac%E4%B8%8B%E4%BF%AE%E6%94%B9hosts%E6%96%87%E4%BB%B6.html",
    "strippedContent": " ```vim sudo vim /private/etc/hosts ```  "
  },
  {
    "title": "brew 命令",
    "path": "/Posts/Terminal/mac%E4%B8%8B%E4%BD%BF%E7%94%A8homebrew.html",
    "strippedContent": " 查看用 brew 安装的文件  `brew list`  `brew list`软件名 可以查看路径  使用`vscode` 在`terminal`打开文件 `code ./`  需要在`vscode`中安装`code`命令 "
  },
  {
    "title": "leetcode初级算法",
    "path": "/Posts/leetcode/LeetCode.html",
    "strippedContent": " ### 26.从排序数组中删除重复项  解题思路： 一级循环从左至右遍历数组，对比对象为该循环索引右侧的所有元素，所以二级循环取从右到左，并终止于一级循环索引数 i， 遇到相同元素，立即删除右侧（二级循环中的）元素并变更原始数组，以保证一级循环过的元素都是唯一的。  ```JavaScript /** * @param {number[]} nums * @return {number} */ var removeDuplicates = function(nums) {  // return [...new Set(nums)]  // return Array.from(new Set(nums))  // nums = [...new Set(nums)]  // return nums  for(i=0;i<nums.length;i++){    for(j=nums.length-1;j>i;j--){      if(nums[i]==nums[j]){        nums.splice(i,1)      }    }  } };  ``` "
  },
  {
    "title": "起步",
    "path": "/Posts/Element/%E8%B5%B7%E6%AD%A5.html",
    "strippedContent": " # 起步    ### 本套源码为 2.5.3 版本    ![](https://ws1.sinaimg.cn/large/bd97bb05gy1g0bhl5xtg6j20bg0o6wfe.jpg)    <tabel>  <tbody>    <tr>      <td>build</td>      <td>编译相关</td>    </tr>    <tr>      <td>examples</td>      <td>示例代码</td>    </tr>    <tr>      <td>packages</td>      <td>组件</td>    </tr>    <tr>      <td>src</td>      <td>相关入口/工具函数</td>    </tr>    <tr>        <td>test/unit</td>      <td>测试相关</td>    </tr>    <tr>      <td>types</td>      <td>接口声明</td>    </tr>  </tbody>  </tabel>    ```json    \"scripts\": {      \"bootstrap\": \"安装依赖\",      \"build:file\": \"编译源代码入口\",      \"build:theme\": \"编译主题相关\",      \"build:utils\": \"编译语言相关\",      \"build:umd\": \"编译语言相关/umd版本\",      \"clean\": \"rimraf lib && rimraf packages/*/lib && rimraf test/**/coverage\",      \"deploy:build\": \"npm run build:file && cross-env NODE_ENV=production webpack --config build/webpack.demo.js && echo element.eleme.io>>examples/element-ui/CNAME\",      \"dev\": \"运行开发模式 8085\",      \"dev:play\": \"npm run build:file && cross-env NODE_ENV=development PLAY_ENV=true webpack-dev-server --config build/webpack.demo.js\",      \"dist\": \"打包\",      \"i18n\": \"i18n相关\",      \"lint\": \"lint相关\",      \"pub\": \"运行sh脚步 一次编译并部署\",      \"test\": \"测试\",      \"test:watch\": \"测试实时监测\"    },    ```    查看`makefile`文件 执行`make`命令    使用`yarn`或`npm`安装依赖    安装完依赖之后执行`dev`命令    ```nodejs  yarn bootstrap    yarn dev  ```    运行完 dev 命令后在`build`文件夹下`webpack.demo.js`查看端口号    ```js    devServer: {      host: '0.0.0.0',      port: 8085,      publicPath: '/',      noInfo: true    },  ```    打开[localhost:8085](localhost:8085)预览项目    "
  },
  {
    "title": "javascript 实现图",
    "path": "/Posts/Nodejs/Sequelize%E7%9A%84%E9%85%8D%E7%BD%AE.html",
    "strippedContent": " # Nodejs ORM Sequelize 的基础配置    ORM    > Object-Relational Mapping，把关系数据库的表结构映射到对象上。    使用 npm 安装 Sequelize 与 mysql    mysql 是驱动我们不使用但是 Sequelize 会使用  "
  },
  {
    "title": "git常用命令",
    "path": "/Posts/Terminal/GIt%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html",
    "strippedContent": " # Git 配置用户信息与 SSH 密钥    ### 安装完 Git 第一件事要配置自己的信息    查看  ```git      $ git config user.name       $ git config user.email  ```  设置  ```git      $ git config --global user.name \"John Doe\"      $ git config --global user.email \"johndoe@example.com\"  ```    ### 连接远程仓库要配置自己的 ssh 秘钥    默认情况下，用户的 SSH 私钥存储在其 ~/.ssh 目录下。 进入该目录并列出其中内容，你便可以快速确认自己是否已拥有私钥：    ```git      $ cd ~/.ssh      $ ls      authorized_keys2  id_dsa       known_hosts      config            id_dsa.pub        cat id_dsa.pub  ```    ### 如果没有 SSH 私钥则需要创建一个私钥来放到 Github 上面使用    ```git      $ ssh-keygen      Generating public/private rsa key pair.      Enter file in which to save the key (/home/schacon/.ssh/id_rsa):      Created directory '/home/schacon/.ssh'.      Enter passphrase (empty for no passphrase):      Enter same passphrase again:      Your identification has been saved in /home/schacon/.ssh/id_rsa.      Your public key has been saved in /home/schacon/.ssh/id_rsa.pub.      The key fingerprint is:      d0:82:24:8e:d7:f1:bb:9b:33:53:96:93:49:da:9b:e3 schacon@mylaptop.local  ```  ### 查看全局安装过的包  ```  npm list -g --depth 0  ```"
  },
  {
    "title": "vscode配置",
    "path": "/Posts/Vscode/%E9%85%8D%E7%BD%AE.html",
    "strippedContent": " ```json  {    \"editor.fontFamily\": \"Consolas, 'Courier New', monospace\",    \"editor.tabSize\": 2,    \"editor.fontSize\": 14,    \"workbench.iconTheme\": \"vscode-icons\",    \"workbench.colorTheme\": \"One Dark Pro\",    \"window.zoomLevel\": 0,    \"extensions.ignoreRecommendations\": true,    \"emmet.syntaxProfiles\": {      \"vue-html\": \"html\",      \"vue\": \"html\"    },      \"eslint.options\": {      \"plugins\": [\"html\"]    },    \"eslint.validate\": [      \"javascript\",      \"javascriptreact\",      \"html\",      \"vue\",      {        \"language\": \"html\",        \"autoFix\": true      },      {        \"language\": \"vue\",        \"autoFix\": true      }    ],    \"prettier.singleQuote\": true,    \"prettier.semi\": false,    \"prettier.eslintIntegration\": true,    \"vetur.validation.template\": false,    // 使用 js-beautify-html 插件格式化 html    \"vetur.format.defaultFormatter.html\": \"js-beautify-html\",    // 格式化插件的配置    \"vetur.format.defaultFormatterOptions\": {      \"js-beautify-html\": {        // 属性强制折行对齐        \"wrap_attributes\": \"force-aligned\"      }    }  }  ```  "
  },
  {
    "title": "Axios 基础配置",
    "path": "/Posts/Vue/Axios%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE.html",
    "strippedContent": " # Axios 基础配置  ### 全局的 axios 默认值  引入 axios 后  ```js axios.defaults.baseURL = 'https://api.example.com'; axios.defaults.headers.common['Authorization'] = AUTH_TOKEN; axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; ```  ### 自定义实例默认值  ```js // 创建实例时设置配置的默认值 var instance = axios.create({ baseURL: 'https://api.example.com' });  // 在实例已创建后修改默认值 instance.defaults.headers.post['Content-Type'] = 'application/json' instance.defaults.headers.common['Authorization'] = AUTH_TOKEN; ``` "
  },
  {
    "title": "javascript 实现图",
    "path": "/Posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/javascript%E5%AE%9E%E7%8E%B0%E5%9B%BE.html",
    "strippedContent": " 由一条边连接在一起的顶点称为相邻顶点。比如，A 和 B 是相邻的，A 和 D 是相邻的，A 和 C 是相邻的，A 和 E 不是相邻的。 一个顶点的度是其相邻顶点的数量。比如，A 和其他三个顶点相连接，因此，A 的度为 3；E 和其他两个顶点相连，因此，E 的度为 2。 路径是顶点 v1, v2,…,vk 的一个连续序列，其中 vi 和 vi+1 是相邻的。以上一示意图中的图为例， 其中包含路径 A B E I 和 A C D G。 简单路径要求不包含重复的顶点。举个例子，A D G 是一条简单路径。除去最后一个顶点（因 为它和第一个顶点是同一个顶点），环也是一个简单路径，比如 A D C A（最后一个顶点重新回到 A）。  ### 有向图  如果图中不存在环，则称该图是无环的。如果图中每两个顶点间都存在路径，则该图是连通的。  ![图](http://or2vgb0pq.bkt.clouddn.com//18-10-29/45067468.jpg)  图还可以是未加权的（目前为止我们看到的图都是未加权的）或是加权的。如下图所示，加 权图的边被赋予了权值：  ![加权图](http://or2vgb0pq.bkt.clouddn.com/18-10-29/23327009.jpg)  我们可以使用图来解决计算机科学世界中的很多问题，比如搜索图中的一个特定顶点或搜索 一条特定边，寻找图中的一条路径（从一个顶点到另一个顶点），寻找两个顶点之间的最短路径， 以及环检测。  ### 邻接矩阵  图最常见的实现是邻接矩阵。每个节点都和一个整数相关联，该整数将作为数组的索引。我 们用一个二维数组来表示顶点之间的连接。如果索引为 i 的节点和索引为 j 的节点相邻，则 array[i][j] === 1，否则 array[i][j] === 0，如下图所示 ![邻接矩阵](http://or2vgb0pq.bkt.clouddn.com//18-10-29/71130959.jpg)  ### 邻接表  我们也可以使用一种叫作邻接表的动态数据结构来表示图。邻接表由图中每个顶点的相邻顶 点列表所组成。存在好几种方式来表示这种数据结构。我们可以用列表（数组）、链表，甚至是 散列表或是字典来表示相邻顶点列表。下面的示意图展示了邻接表数据结构 ![邻接表](http://or2vgb0pq.bkt.clouddn.com//18-10-29/43873809.jpg)  ### 关联矩阵  我们还可以用关联矩阵来表示图。在关联矩阵中，矩阵的行表示顶点，列表示边。如下图所 示，我们使用二维数组来表示两者之间的连通性，如果顶点 v 是边 e 的入射点，则 array[v][e] === 1； 否则，array[v][e] === 0  ![关联矩阵](http://or2vgb0pq.bkt.clouddn.com//18-10-29/9738760.jpg)  ```JavaScript  //需要用到的队列类 class Queue {   constructor() {     this.items = []   }   //相队列尾部添加一个元素   enqueue(element) {     this.items.push(element)   }   //移除队列的一个个元素   dequeue() {     return this.items.shift()   }   // 返回队列第一个元素,第一个被添加的元素   front() {     return this.items[0]   }   // 查看队列是否为空   isEmpty() {     return this.items.length == 0   }   // 清除队列   clear() {     this.items = []   }   // 返回队列包含的元素个数   size() {     return this.items.length   }   print() {     console.log(this.items.toString())   } } //需要用到字典类型 function Dictionary() {   var items = {}    this.has = function(key) {     return key in items   }   this.set = function(key, value) {     items[key] = value   }   this.remove = function() {     if (this.has(key)) {       delete items[key]       return true     }     return false   }   this.get = function(key) {     return this.has(key) ? items[key] : nuderfined   }   this.values = function() {     var values = []     for (var k in items) {       if (this.has(k)) {         values.push(items[k])       }     }     return values   }   this.clear = function() {     items = {}   }   this.size = function() {     return Object.keys(items).length   }   this.keys = function() {     return Object.keys(items)   }   this.getItems = function() {     return items   } }  function Graph() {   //用一个数组存储顶点的名字   var vertices = []   //用一个字典存储邻接表   var adjList = new Dictionary()   //这个方法接受顶点v作为参数   this.addVertex = function(v) {     //将顶点加到顶点列表中     vertices.push(v)     // 在邻接表中设置v为键对于值为一个空数组     adjList.set(v, [])   }   //这个方法接受两个顶点作为参数   this.addEdge = function(v, w) {     // 通过将w加入到v的邻接表中，我们添加了一条自顶 点v到顶点w的边     adjList.get(v).push(w)     // 无向图我们需要添加一条自w向v的边     adjList.get(w).push(v)   }   //实现一下Graph类的toString方法，以便于在控制台输出图   this.toString = function() {     var s = ''     for (var i = 0; i < vertices.length; i++) {       s += vertices[i] + ' -> '       var neighbors = adjList.get(vertices[i])       for (var j = 0; j < neighbors.length; j++) {         s += neighbors[j] + ' '       }       s += '\\n'     }     return s   }   var initializeColor = function() {     var color = []     for (var i = 0; i < vertices.length; i++) {       color[vertices[i]] = 'white' //1     }     return color   }   // 广度优先搜索   this.bfs = function(v, callback) {     var color = initializeColor() //2     var queue = new Queue() //3     queue.enqueue(v) //4      while (!queue.isEmpty()) {       //5       var u = queue.dequeue() //6       var neighbors = adjList.get(u) //7       color[u] = 'grey' //8       for (var i = 0; i < neighbors.length; i++) {         //9         var w = neighbors[i] //10         if (color[w] === 'white') {           //11           color[w] = 'grey' //12           queue.enqueue(w) //13         }       }       color[u] = 'black' //14       if (callback) {         //15         callback(u)       }     }   } }  } // 测试这段代码： var graph = new Graph() var myVertices = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'] for (var i = 0; i < myVertices.length; i++) {   graph.addVertex(myVertices[i]) } graph.addEdge('A', 'B') graph.addEdge('A', 'C') graph.addEdge('A', 'D') graph.addEdge('C', 'D') graph.addEdge('C', 'G') graph.addEdge('D', 'G') graph.addEdge('D', 'H') graph.addEdge('B', 'E') graph.addEdge('B', 'F') graph.addEdge('E', 'I') console.log(graph.toString()) function printNode(value) {   console.log('Visited vertex: ' + value) } //广度优先搜索 graph.bfs(myVertices[0], printNode) // 输出结果为:  /**   A -> B C D   B -> A E F   C -> A D G   D -> A C G H   E -> B I   F -> B   G -> C D   H -> D   I -> E    Visited vertex: A   Visited vertex: B   Visited vertex: C   Visited vertex: D   Visited vertex: E   Visited vertex: F   Visited vertex: G   Visited vertex: H   Visited vertex: I */ ```  <disqus/> "
  },
  {
    "title": "javascript 实现字典散列表",
    "path": "/Posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/javascript%E5%AE%9E%E7%8E%B0%E5%AD%97%E5%85%B8%E6%95%A3%E5%88%97%E8%A1%A8.html",
    "strippedContent": " 你已经知道，集合表示一组互不相同的元素（不重复的元素）。在字典中，存储的是[键，值] 对，其中键名是用来查询特定元素的。字典和集合很相似，集合以[值，值]的形式存储元素，字 典则是以[键，值]的形式来存储元素。字典也称作映射。    将要实现的类就是以 ECMAScript 6 中 Map 类的实现为基础的。你会发现它和 Set 类很相似（但不同于存储[值，值]对的形式，我们将要存储的是[键，值]对）。    ```javascript  function Dictionary() {    var items = {}      this.has = function(key) {      return key in items    }    this.set = function(key, value) {      items[key] = value    }    this.remove = function() {      if (this.has(key)) {        delete items[key]        return true      }      return false    }    this.get = function(key) {      return this.has(key) ? items[key] : nuderfined    }    this.values = function() {      var values = []      for (var k in items) {        if (this.has(k)) {          values.push(items[k])        }      }      return values    }    this.clear = function() {      items = {}    }    this.size = function() {      return Object.keys(items).length    }    this.keys = function() {      return Object.keys(items)    }    this.getItems = function() {      return items    }  }  var dictionary = new Dictionary()  ```    ```javascript  // var loseloseHashCode = function(key) {  //   var hash = 0  //   for (var i = 0; i < key.length; i++) {  //     hash += key.charCodeAt(i)  //   }  //   return hash % 37  // }  var loseloseHashCode = function(key) {    var hash = 5381    for (var i = 0; i < key.length; i++) {      hash = hash * 33 + key.charCodeAt(i)    }    return hash % 1013  }  function HashTable() {    var table = []    this.put = function(key, value) {      var position = loseloseHashCode(key)      console.log(position + '-' + key)      table[position] = value    }    this.get = function(key) {      return table[loseloseHashCode(key)]    }    this.remove = function(key) {      table[loseloseHashCode(key)] = undefined    }  }  var hash = new HashTable()  hash.put('Gandalf', 'gandalf@email.com')  hash.put('John', 'johnsnow@email.com')  hash.put('Tyrion', 'tyrion@email.com')  console.log(hash.get('Gandalf'))  console.log(hash.get('Loiane'))  hash.remove('Gandalf')  console.log(hash.get('Gandalf'))  ```  "
  },
  {
    "title": "JavaScript 实现排序算法",
    "path": "/Posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/javascript%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html",
    "strippedContent": " #### 冒泡排序    冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。    1. 比较相邻的元素。如果第一个比第二个大，就交换它们两个；  2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；  3. 针对所有的元素重复以上的步骤，除了最后一个；  4. 重复步骤 1~3，直到排序完成。     > 冒泡排序    ```javascript  var bubbleSort = function(arr) {    var i, j, m, noswap    var len = arr.length    if (len <= 1) {      return    }    console.time('冒泡排序耗时')    for (i = 0; i < len; i++) {      noswap = true      for (j = 0; j < len - i - 1; j++) {        if (arr[j] > arr[j + 1]) {          m = arr[j]          arr[j] = arr[j + 1]          arr[j + 1] = m          noswap = false        }      }      if (noswap) {        break      }    }    console.timeEnd('冒泡排序耗时')    return arr  }    console.log(bubbleSort([2, 3, 4, 5, 1, 2, 23, 4, 5, 6, 79]))  ```    #### 选择排序    选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。    > 选择排序    ```javascript  function selectionSort(arr) {    var len = arr.length    var minIndex, temp    console.time('选择排序耗时')    for (var i = 0; i < len - 1; i++) {      minIndex = i      for (var j = i + 1; j < len; j++) {        if (arr[j] < arr[minIndex]) {          minIndex = j        }      }      temp = arr[i]      arr[i] = arr[minIndex]      arr[minIndex] = temp    }    console.timeEnd('选择排序耗时')    return arr  }  var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]  console.log(selectionSort(arr)) //[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]  ```    #### 插入排序    插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到 O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。    1. 从第一个元素开始，该元素可以认为已经被排序；  2. 取出下一个元素，在已经排序的元素序列中从后向前扫描；  3. 如果该元素（已排序）大于新元素，将该元素移到下一位置；  4. 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；  5. 将新元素插入到该位置后；  6. 重复步骤 2~5。    > 插入排序    ```javascript  function insertionSort(arr) {    var len = arr.length    console.time('插入排序耗时')    for (var i = 1; i < len; i++) {      var key = arr[i]      var j = i - 1      while (j >= 0 && arr[j] > key) {        arr[j + 1] = arr[j]        j--      }      arr[j + 1] = key    }    console.timeEnd('插入排序耗时')    return arr  }  var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]  console.log(insertionSort(arr))  ```    #### 快速排序    排序算法（Sorting algorithm）是计算机科学最古老、最基本的课题之一。要想成为合格的程序员，就必须理解和掌握各种排序算法。    目前，最常见的排序算法大概有七八种，其中\"快速排序\"（Quicksort）使用得最广泛，速度也较快。它是图灵奖得主 C. A. R. Hoare（1934--）于 1960 时提出来的。    1. 在数据集之中，选择一个元素作为\"基准\"（pivot）。  2. 所有小于\"基准\"的元素，都移到\"基准\"的左边；所有大于\"基准\"的元素，都移到\"基准\"的右边。  3. 对\"基准\"左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。    > 快速排序    ```javascript  var quickSort = function(arr) {    if (arr.length <= 1) {      return arr    }    var pivotIndex = Math.floor(arr.length / 2)    var pivot = arr.splice(pivotIndex, 1)[0]    var left = []    var right = []    for (var i = 0; i < arr.length; i++) {      if (arr[i] < pivot) {        left.push(arr[i])      } else {        right.push(arr[i])      }    }    return quickSort(left).concat([pivot], quickSort(right))  }  var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]  console.log(quickSort(arr))  ```    <script>  export default {    method:{      },    mounted () {      console.log(`运行:`)      console.log(`var quickSort = function (arr) {        if (arr.length <= 1) {          return arr        }        var pivotIndex = Math.floor(arr.length / 2)        var pivot = arr.splice(pivotIndex, 1)[0]        var left = []        var right = []        for (var i = 0; i < arr.length; i++) {          if (arr[i] < pivot) {            left.push(arr[i])          } else {            right.push(arr[i])          }        }        return quickSort(left).concat([pivot], quickSort(right))      }      var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]      console.log(quickSort(arr))      `)      var quickSort = function (arr) {        if (arr.length <= 1) {          return arr        }        var pivotIndex = Math.floor(arr.length / 2)        var pivot = arr.splice(pivotIndex, 1)[0]        var left = []        var right = []        for (var i = 0; i < arr.length; i++) {          if (arr[i] < pivot) {            left.push(arr[i])          } else {            right.push(arr[i])          }        }        return quickSort(left).concat([pivot], quickSort(right))      }      var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]        console.log(`输出:`)      console.log(quickSort(arr))    }  }  </script>  "
  },
  {
    "title": "javascript 实现栈",
    "path": "/Posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/javascript%E5%AE%9E%E7%8E%B0%E6%A0%88.html",
    "strippedContent": " 栈是一种遵从后进先出（LIFO）原则的有序集合。新添加的或待删除的元素都保存在栈的 末尾，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。    在现实生活中也能发现很多栈的例子。例如，下图里的一摞书或者餐厅里堆放的盘子。    我们将创建一个类来表示栈。让我们从基础开始，先声明这个类：    ```javascript  function Stack() {    //各种属性和方法的声明    var items = []    //添加一个（或几个）新元素到栈顶    this.push = function(item) {      items.push(item)    }    //移除栈顶的元素，同时返回被移除的元素。    this.pop = function() {      return items.pop()    }    //返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返 回它）    this.peek = function() {      return items.length - 1    }    //如果栈里没有任何元素就返回true，否则返回false。    this.isEmpty = function() {      return items == []    }    //移除栈里的所有元素    this.clear = function() {      items = []    }    //返回栈里的元素个数。    this.size = function() {      return items.length    }    this.print = function() {      console.log(items.toString())    }  }  ```    使用刚刚声明的栈方法实现一个十进制数转二进制数的算法    要把十进制转化成二进制，我们可以将该十进制数字和 2 整除（二进制是满二进一），直到结 果是 0 为止    ```JavaScript  function divideBy2(decNumber){      var remStack = new Stack(),        rem,        binaryString ='';      while (decNumber >0 ){      rem = Math.floor(decNumber % 2);      remStack.push(rem);      decNumber = Math.floor(decNumber / 2)    }      while (!remStack.isEmpty()){      binaryString += remStack.pop().toString();    }      return binaryString  }  ```    我们很容易修改之前的算法，使之能把十进制转换成任何进制。除了让十进制数字和 2 整除 转成二进制数，还可以传入其他任意进制的基数为参数，就像下面算法这样：    ```JavaScript  function baseConverter(decNumber,base){      var remStack = new Stack(),        rem,        baseString = '',        digits = '0123456789ABCDEF';      while (decNumber >0){      rem = Math.floor(decNumber % base);      remStack.push(rem);      decNumber = Math.floor(decNumber / base)    }      while (!remStack.isEmpty()){      baseString +=  digits[remStack.pop()];    }      return baseString;  }  ```    <script>  export default {    mounted () {      function Stack() {        //各种属性和方法的声明        var items = []        //添加一个（或几个）新元素到栈顶        this.push = function(item) {          items.push(item)        }        //移除栈顶的元素，同时返回被移除的元素。        this.pop = function() {          return items.pop()        }        //返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返 回它）        this.peek = function() {          return items.length - 1        }        //如果栈里没有任何元素就返回true，否则返回false。        this.isEmpty = function() {          return items == []        }        //移除栈里的所有元素        this.clear = function() {          items = []        }        //返回栈里的元素个数。        this.size = function() {          return items.length        }        this.print = function() {          console.log(items.toString())        }      }      function baseConverter(decNumber,base){          var remStack = new Stack(),              rem,              baseString = '',              digits = '0123456789ABCDEF';                    while (decNumber >0){            rem = Math.floor(decNumber % base);            remStack.push(rem);            decNumber = Math.floor(decNumber / base)          }            while (!remStack.isEmpty()){            baseString +=  digits[remStack.pop()];           }          return baseString;       }      // console.log(baseConverter(1345, 2))       // console.log(baseConverter(100345, 8))       // console.log(baseConverter(100345, 16))    }  }  </script>  "
  },
  {
    "title": "JavaScript 实现简单二叉查找树",
    "path": "/Posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/javascript%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91.html",
    "strippedContent": " ![二叉树](http://or2vgb0pq.bkt.clouddn.com//18-10-29/46844758.jpg)    二叉树：二叉树就是一种数据结构， 它的组织关系就像是自然界中的树一样。官方语言的定义是：是一个有限元素的集合,该集合或者为空、或者由一个称为根的元素及两个不相交的、被分别称为左子树和右子树的二叉树组成。    节点： 树中的每个元素称为一个节点，    根节点： 位于整棵树顶点的节点，它没有父节点。    子节点： 其他节点的后代    叶子节点: 没有子节点的元素称为叶子节点。    #### 二叉树创建代码的实现    > 创建二叉树    ```javascript  // 声明根节点  var root = null  // 声明函数  function BinarSearchTree() {    var Node = function(key) {      this.key = key      this.left = null      this.right = null    }      // 这个方法会通过递归得调用自身，来找到新添加节点的合适位置    var insertNode = function(node, newNode) {      // 判断插入左节点还是右节点,然后递归调用      if (newNode.key <= node.key) {        if (node.left === null) {          node.left = newNode        } else {          insertNode(node.left, newNode)        }      } else {        if (node.right === null) {          node.right = newNode        } else {          insertNode(node.right, newNode)        }      }      // 判断创建根节点还是插入子节点      this.insert = function(key) {        // 创建一个用来表示新节点的Node类实例，因此需要new一下Node类并传入需要插入的key值，它会自动初始化为左右节点为null的一个新节点        var newNode = new Node(key)        // 先判断树是否为空，若为空，新插入的节点就作为根节点，如不为空，调用一个辅助方法insertNode()方法，将根节点和新节点传入        if (root === null) {          root = newNode        } else {          insertNode(root, newNode)        }      }    }  }  //定义要插入的二叉树  var nodes = [7, 3, 6, 2, 8, 13, 5, 15]  // 实例化二叉树函数  var _binarSearchTree = new BinarSearchTree()  // 遍历数组插入节点  nodes.forEach(key => {    _binarSearchTree.insert(key)  })  //查看二叉树输出结果】  console.log(root)  ```    #### 二叉树的中序遍历    中序遍历（LDR）是二叉树遍历的一种，也叫做中根遍历、中序周游。在二叉树中，先左后根再右。巧记：左根右。    中序便历可用于排序。    以下代码先查找最左叶子节点然后打印出来，如果没有最左叶子节点则打印根节点，最后打印右子节点。    > 中序遍历    ```javascript        var inOrderTraverseNode = function (node) {          // 判断当前节点如果不为空则递归查找节点，按照左根右的顺序          if (node !== null) {            // 先查找左叶子节点，如果左叶子节点有值则递归此节点            inOrderTraverseNode(node.left)            // 如果没有左叶子节点则打印当前根节点            console.log(node.key)            // 最后查找右子节点            inOrderTraverseNode(node.right)          }        }        //中序遍历        this.inOrderTraverse = function () {          // 将二叉树根节点传入          inOrderTraverseNode(root)        }      }  ```    #### 二叉树的先序遍历    先序遍历(Pre-order)，按照根左右的顺序沿一定路径经过路径上所有的结点。在二叉树中，先根后左再右。巧记：根左右。    先序遍历常用于复制二叉树。    先序遍历与中序遍历代码很像，只不过先查找根节点打印出来，然后在查找最左叶子节点然后打印出来，最后打印右子节点。    > 先序遍历    ```javascript  var preOrderTraverseNode = function(node) {    if (node !== null) {      // 先打印当前节点然后在查找左右子节点      console.log(node.key)      preOrderTraverseNode(node.left)      preOrderTraverseNode(node.right)    }  }  this.preOrderTraverse = function() {    preOrderTraverseNode(root)  }  ```    #### 二叉树的后序遍历    后序遍历（LRD）是二叉树遍历的一种，也叫做后根遍历、后序周游，可记做左右根。后序遍历有递归算法和非递归算法两种。在二叉树中，先左后右再根。巧记：左右根。    后序遍历实际应用于操作系统的文件系统遍历中。    后序遍历与上面两个遍历一样，这回变为左右根的顺序。    > 后序遍历    ```javascript  this.postOrderTraverse = function() {    postOrderTraverseNode(root)  }  var postOrderTraverseNode = function(node) {    if (node !== null) {      postOrderTraverseNode(node.left)      postOrderTraverseNode(node.right)      // 如果没有左右子节点最后打印根节点      console.log(node.key)    }  }  ```    #### 二叉树查找最大值与最小值    二叉树的最左子节点为最小，最右节点为最大，按照这个规律我们只需要递归查找最左与最右子节点就可以查到最大与最下值。    > 查找最小节点    ```javascript  var minNode = function(node) {    if (node) {      // 如果当前节点不为空并且含有左子节点      while (node && node.left !== null) {        node = node.left      }      return node.key    }  }  // 查找最小节点  this.min = function() {    return minNode(root)  }  ```    > 查找最大节点    ```javascript  var maxNode = function(node) {    if (node) {      // 如果当前节点不为空并且含有右子节点      while (node && node.right !== null) {        node = node.right      }      return node.key    }  }  // 查找最大节点  this.max = function() {    return maxNode(root)  }  ```    #### 二叉树查找指定值    实现查找二叉树特定值这个方法首先检验 node 的合法性，如果为 null，直接退出，并返回 fasle。如果传入的 key 比当前传入 node 的 key 值小，它会继续递归查找 node 的左侧节点，反之，查找右侧节点。如果找到相等节点，直接退出，并返回 true。    > 查找指定值    ```javascript  var searchNode = function(node, key) {    // 如果节点为空则返回    if (node === null) {      return false    }      if (key < node.key) {      // 如果查找值小于当前节点值则查找左子节点      return searchNode(node.left, key)    } else if (key > node.key) {      // 如果查找值大于当前节点值则查找右子节点      return searchNode(node.right, key)    } else {      return true    }  }  // 查找指定节点  this.search = function(key) {    return searchNode(root, key)  }  ```    #### 移除节点    移除节点的实现情况比较复杂，它会有三种不同的情况：    1.  需要移除的节点是一个叶子节点    2.  需要移除的节点包含一个子节点    3.  需要移除的节点包含两个子节点    和实现搜索指定节点一元，要移除某个节点，必须先找到它所在的位置，因此移除方法的实现中部分代码和上面相同，其中，移除包含两个子节点的节点是最复杂的情况，它包含左侧节点和右侧节点，对它进行移除主要需要三个步骤：    1.  需要找到它右侧子树中的最小节点来代替它的位置  2.  将它右侧子树中的最小节点移除  3.  将更新后的节点的引用指向原节点的父节点    有点绕，但必须这样，因为删除元素后的二叉搜索树必须保持它的排序性质。    > 移除节点    ```javascript  var removeNode = function(node, key) {    if (node == null) {      return null    }    if (key < node.key) {      node.left = removeNode(node.left, key)      return node    } else if (key > node.key) {      node.right = removeNode(node.right, key)      return node    } else {      // 需要移除的是一个叶子节点      if (node.left === null && node.right === null) {        node = null        return node      }        //需要移除的节点包含一个叶子节点        if (node.left === null) {        node = node.right        return node      } else if (node.left === null) {        node = node.left        return node      }      //需要移除的节点包含两个子节点      var aux = findMinNode(node.right)      node.key = aux.key      node.right = removeNode(node.right, axu.key)      return node    }  }  var findMinNode = function(node) {    if (node) {      while (node && node.left !== null) {        node = node.left      }      return node    }    return null  }  //移除节点  this.remove = function(key) {    removeNode(root, key)  }  ```    > 完整代码    ```javascript  // 声明根节点  var root = null  // 声明函数  function BinarSearchTree() {    var Node = function(key) {      this.key = key      this.left = null      this.right = null    }    // 判断创建根节点还是插入子节点    this.insert = function(key) {      var newNode = new Node(key)      if (root === null) {        root = newNode      } else {        insertNode(root, newNode)      }    }    // 判断插入左节点还是右节点    var insertNode = function(node, newNode) {      if (newNode.key <= node.key) {        if (node.left === null) {          node.left = newNode        } else {          insertNode(node.left, newNode)        }      } else {        if (node.right === null) {          node.right = newNode        } else {          insertNode(node.right, newNode)        }      }    }      var inOrderTraverseNode = function(node) {      // 判断当前节点如果不为空则递归查找节点，按照左根右的顺序      if (node !== null) {        // 先查找左叶子节点，如果左叶子节点有值则递归此节点        inOrderTraverseNode(node.left)        // 如果没有左叶子节点则打印当前根节点        console.log(node.key)        // 最后查找右子节点        inOrderTraverseNode(node.right)      }    }    //中序遍历    this.inOrderTraverse = function() {      // 将二叉树根节点传入      inOrderTraverseNode(root)    }      var preOrderTraverseNode = function(node) {      if (node !== null) {        console.log(node.key)        preOrderTraverseNode(node.left)        preOrderTraverseNode(node.right)      }    }    // 先序遍历    this.preOrderTraverse = function() {      preOrderTraverseNode(root)    }      var postOrderTraverseNode = function(node) {      if (node !== null) {        postOrderTraverseNode(node.left)        postOrderTraverseNode(node.right)        // 如果没有左右子节点最后打印根节点        console.log(node.key)      }    }    // 后序遍历    this.postOrderTraverse = function() {      postOrderTraverseNode(root)    }      var minNode = function(node) {      if (node) {        // 如果当前节点不为空并且含有左子节点        while (node && node.left !== null) {          node = node.left        }        return node.key      }    }    // 查找最小节点    this.min = function() {      return minNode(root)    }    var maxNode = function(node) {      if (node) {        // 如果当前节点不为空并且含有右子节点        while (node && node.right !== null) {          node = node.right        }        return node.key      }    }    //查找最大节点    this.max = function() {      return maxNode(root)    }    var searchNode = function(node, key) {      // 如果节点为空则返回      if (node === null) {        return false      }        if (key < node.key) {        // 如果查找值小于当前节点值则查找左子节点        return searchNode(node.left, key)      } else if (key > node.key) {        // 如果查找值大于当前节点值则查找右子节点        return searchNode(node.right, key)      } else {        return true      }    }    // 查找指定节点    this.search = function(key) {      return searchNode(root, key)    }    var removeNode = function(node, key) {      if (node == null) {        return null      }      if (key < node.key) {        node.left = removeNode(node.left, key)        return node      } else if (key > node.key) {        node.right = removeNode(node.right, key)        return node      } else {        // 需要移除的是一个叶子节点        if (node.left === null && node.right === null) {          node = null          return node        }          //需要移除的节点包含一个叶子节点          if (node.left === null) {          node = node.right          return node        } else if (node.left === null) {          node = node.left          return node        }        //需要移除的节点包含两个子节点        var aux = findMinNode(node.right)        node.key = aux.key        node.right = removeNode(node.right, axu.key)        return node      }    }    var findMinNode = function(node) {      if (node) {        while (node && node.left !== null) {          node = node.left        }        return node      }      return null    }    //移除节点    this.remove = function(key) {      removeNode(root, key)    }  }    var nodes = [7, 3, 6, 2, 8, 13, 5, 15]  var _binarSearchTree = new BinarSearchTree()  nodes.forEach(key => {    _binarSearchTree.insert(key)  })  // 打印插入完的二叉树  console.log(root)  // 调用中序遍历方法  _binarSearchTree.inOrderTraverse()  // 调用先序遍历方法  _binarSearchTree.preOrderTraverse()  // 调用后序遍历方法  _binarSearchTree.postOrderTraverse()  // 查找最小值  console.log(_binarSearchTree.min())  // 查找最大值  console.log(_binarSearchTree.max())  // 查找特定值  console.log(_binarSearchTree.search(2))  // 删除节点  _binarSearchTree.remove(8)  _binarSearchTree.inOrderTraverse()  ```    <script>  export default {    mounted(){       // 声明根节点      var root = null;      // 声明函数      function BinarSearchTree() {        var Node = function (key) {          this.key = key;          this.left = null;          this.right = null;        };        // 判断创建根节点还是插入子节点        this.insert = function (key) {          var newNode = new Node(key)          if (root === null) {            root = newNode          } else {            insertNode(root, newNode)          }        }        // 判断插入左节点还是右节点        var insertNode = function (node, newNode) {          if (newNode.key <= node.key) {            if (node.left === null) {              node.left = newNode            } else {              insertNode(node.left, newNode)            }          } else {            if (node.right === null) {              node.right = newNode            } else {              insertNode(node.right, newNode)            }          }          }          var inOrderTraverseNode = function (node) {          // 判断当前节点如果不为空则递归查找节点，按照左根右的顺序          if (node !== null) {            // 先查找左叶子节点，如果左叶子节点有值则递归此节点            inOrderTraverseNode(node.left)            // 如果没有左叶子节点则打印当前根节点            console.log(node.key)            // 最后查找右子节点            inOrderTraverseNode(node.right)          }        }        //中序遍历        this.inOrderTraverse = function () {          // 将二叉树根节点传入          inOrderTraverseNode(root)        }          var preOrderTraverseNode = function (node) {          if (node !== null) {            console.log(node.key)            preOrderTraverseNode(node.left)            preOrderTraverseNode(node.right)          }        }        // 先序遍历        this.preOrderTraverse = function () {          preOrderTraverseNode(root)        }          var postOrderTraverseNode = function (node) {          if (node !== null) {            postOrderTraverseNode(node.left)            postOrderTraverseNode(node.right)            // 如果没有左右子节点最后打印根节点            console.log(node.key)          }        }        // 后序遍历        this.postOrderTraverse = function () {          postOrderTraverseNode(root)        }          var minNode = function (node) {          if (node) {            // 如果当前节点不为空并且含有左子节点            while (node && node.left !== null) {              node = node.left            }            return node.key          }        }        // 查找最小节点        this.min = function () {          return minNode(root)        }        var maxNode = function (node) {          if (node) {            // 如果当前节点不为空并且含有右子节点            while (node && node.right !== null) {              node = node.right            }            return node.key          }        }        this.max = function () {          return maxNode(root)        }        var searchNode = function (node, key) {          // 如果节点为空则返回          if (node === null) {            return false          }            if (key < node.key) {            // 如果查找值小于当前节点值则查找左子节点            return searchNode(node.left, key)          } else if (key > node.key) {            // 如果查找值大于当前节点值则查找右子节点            return searchNode(node.right, key)          } else {            return true          }        }        // 查找指定节点        this.search = function (key) {          return searchNode(root, key)        }        var removeNode = function (node, key) {          if (node == null) {            return null          }          if (key < node.key) {            node.left = removeNode(node.left, key)            return node          } else if (key > node.key) {            node.right = removeNode(node.right, key)            return node          } else {            // 需要移除的是一个叶子节点            if (node.left === null && node.right === null) {              node = null              return node            }              //需要移除的节点包含一个叶子节点              if (node.left === null) {              node = node.right              return node            } else if (node.left === null) {              node = node.left              return node            }            //需要移除的节点包含两个子节点            var aux = findMinNode(node.right)            node.key = aux.key            node.right = removeNode(node.right, axu.key)            return node          }        }        var findMinNode = function (node) {          if (node) {            while (node && node.left !== null) {              node = node.left            }            return node          }          return null        }        //移除节点        this.remove = function (key) {          removeNode(root, key)        }      }        var nodes = [7, 3, 6, 2, 8, 13, 5, 15];      var _binarSearchTree = new BinarSearchTree();      nodes.forEach(key => {        _binarSearchTree.insert(key)      })      // 打印插入完的二叉树      console.log(root)      // 调用中序遍历方法      _binarSearchTree.inOrderTraverse()      // 调用先序遍历方法      _binarSearchTree.preOrderTraverse()      // 调用后序遍历方法      _binarSearchTree.postOrderTraverse()      // 查找最小值      console.log(_binarSearchTree.min())      // 查找最大值      console.log(_binarSearchTree.max())      // 查找特定值      console.log(_binarSearchTree.search(2));      // 删除节点      _binarSearchTree.remove(8)      _binarSearchTree.inOrderTraverse()    }  }  </script>  "
  },
  {
    "title": "javascript 实现链表",
    "path": "/Posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/javascript%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8.html",
    "strippedContent": " 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个 元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。    相对于传统的数组，链表的一个好处在于，添加或移除元素的时候不需要移动其他元素。然 而，链表需要使用指针，因此实现链表时需要额外注意。数组的另一个细节是可以直接访问任何 位置的任何元素，而要想访问链表中间的一个元素，需要从起点（表头）开始迭代列表直到找到 所需的元素。  现实中也有一些链表的例子。第一个例子就是康加舞队。每个人是一个元素，手就是链向下 一个人的指针。可以向队列中增加人——只需要找到想加入的点，断开连接，插入一个人，再重 新连接起来。    另一个例子是寻宝游戏。你有一条线索，这条线索是指向寻找下一条线索的地点的指针。你顺着这条链接去下一个地点，得到另一条指向再下一处的线索。得到列表中间的线索的唯一办法， 就是从起点（第一条线索）顺着列表寻找。  还有一个可能是用来说明链表的最流行的例子，那就是火车。一列火车是由一系列车厢（也 称车皮）组成的。每节车厢或车皮都相互连接。你很容易分离一节车皮，改变它的位置，添加或 移除它。    ### 创建一个链表    ```JavaScript  function LinkedList() {    // 一个辅助类,表示一个节点,包含一个指针,指向下一个节点    var Node = function(element) {      this.element = element      this.next = null    }    // 表示列表项的长度    var length = 0    // 第一个节点的引用    var head = null    // 向链表尾部添加一个新的项    this.append = function(element) {      // 创建一个节点      var node = new Node(element),        current //用于暂存当前项      //如果是空链表 那么 直接让head成为一个节点head.next自动变成null      if (head === null) {        //列表中第一个节点        head = node      } else {        // 当前的head不为null,说明当前的head有next属性        current = head        // 循环链表找到最后一项        while (current.next) {          current = current.next        }        // 当curent.next等于空时说明已经到了最后一项        // 然后把node赋值给最后一项即可        current.next = node      }      // 更新长度      length++    }    // 向链表的特定位置插入一个新的项    this.insert = function(position, element) {      //检查越界值      if (position >= 0 && position <= length) {        var node = new Node(element),          current = head,          previous,          index = 0        //在第一个位置添加        //current是对链表中第一个元素的引用        if (position === 0) {          // 现在head和node.next都指向了current          node.next = current          // 把head的引用改为node          head = node        } else {          // 当跳出循环时，current变量将是对想要插入新元素的位置之后一个 元素的引用，          // 而previous将是对想要插入新元素的位置之前一个元素的引用。          while (index++ < position) {            previous = current            current = current.next          }          // 因此，首先需要把新项（node）和当前项链接起来，然后需要改变previous和current之间的链接。          // 我们还需要让previous.next 指向node。          node.next = current          previous.next = node        }        //更新长度        length++          return true      } else {        return false      }    }    // 从链表中移除一项    this.remove = function(element) {}    // 从链表中的特定位置移除一项    this.removeAt = function(position) {      //检查越界值      if (position > -1 && positon < length) {        var current = head, //暂存当前项          previous, //暂存之前项          index = 0 //索引        // 如果移除第一项,直接让head置空即可        if (position === 0) {          head = current.next        } else {          // 迭代链表          while (index++ < position) {            // 用previous(上一个)暂存current(当前项),当前项指向下一项            previous = current            current = current.next          }          //将previous(上一个))与current(当前的)的下一项连接起来;跳过current,从而移除它          previous.next = current.next        }        // 更新长度        length--        return current.element      } else {        return null      }      // current变量是对要移除元素的引用。previous变量是对要移除元素的前一个元素的引用。      // 那么要移除current元素，需要做的就是将previous.next与current.next链接起来。      // 因此， 我们的逻辑对这两种情况都管用。    }    // 返回元素在链表中的索引    this.indexOf = function(element) {      var current = head,        index = -1      while (current) {        if (element === current.element) {          return index        }        index++        current = current.next      }      return -1    }    // 返回链表是否为空    this.isEmpty = function() {      return length === 0    }    // 返回链表中的元素个数    this.size = function() {      return length    }    // 输出值    this.toString = function() {      var current = head,        string = ''      while (current) {        string = current.element        current = current.next      }      return string    }    this.getHead = function() {      return head    }    this.print = function() {}  }  ```    # 双向链表    ```JavaScript    function DoublyLinkedList() {    var Node = function(element) {      this.element = element      this.next = null      this.prev = null    }      var length = 0    var head = null    var tail = null      this.insert = function(position, element) {      if (position >= 0 && position <= length) {        var node = new Node(element),          current = head,          previous,          index = 0          if (position === 0) {          if (!head) {            //1            head = node            tail = node          } else {            node.next = current            current.prev = node //2            head = node          }        } else if (position === length) {          current = tail //3          current.next = node          node.prev = current          tail = node        } else {          while (index++ < position) { //4            previous = current            current = current.next          }          node.next = current //5          previous.next = node            current.prev = node          node.prev = previous        }        length++        return true      } else {        return false      }    }  }  ```  "
  },
  {
    "title": "javascript 实现集合",
    "path": "/Posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/javascript%E5%AE%9E%E7%8E%B0%E9%9B%86%E5%90%88.html",
    "strippedContent": " 在数学中，集合是一组 不同的对象（的集）。 比如说，一个由大于或等于 0 的整数组成的自然数集合：N = {0, 1, 2, 3, 4, 5, 6, …}。集合中 的对象列表用“{}”（大括号）包围。  还有一个概念叫空集。空集就是不包含任何元素的集合。比如 24 和 29 之间的素数集合。由于 24 和 29 之间没有素数（除了 1 和自身，没有其他正因数的大于 1 的自然数），这个集合就是空集。 空集用“{ }”表示。  你也可以把集合想象成一个既没有重复元素，也没有顺序概念的数组。  在数学中，集合也有并集、交集、差集等基本操作。    - 目前的 JavaScript 实现是基于 2011 年 6 月发布的 ECMAScript 5.1（现代浏览器均已支持），它包 括了我们在之前章节已经提到过的 Array 类的实现。ECMAScript 6（官方名称 ECMAScript 2015， 2015 年 6 月发布）包括了 Set 类的实现。    ```javascript  function Set() {    var items = {}      this.has = function(value) {      return items.hasOwnProperty(value)    }      this.add = function(value) {      if (!this.has(value)) {        items[value] = value        return true      }      return false    }    this.remove = function(value) {      if (this.has(value)) {        delete items[value]        return true      }      return false    }      this.clear = function() {      items = {}    }    this.size = function() {      return Object.keys(items).length    }    this.values = function() {      return Object.keys(items)    }      //并集    this.intersection = function(otherSet) {      var intersectionSet = new Set()      var values = this.values()        for (var i = 0; i < values.length; i++) {        if (otherSet.has(values[i])) {          intersectionSet.add(values[i])        }      }      return intersectionSet    }    //差集    this.difference = function(otherSet) {      var differenceSet = new Set()        var values = this.values()        for (var i = 0; i < values.length; i++) {        if (!otherSet.has(values[i])) {          differenceSet.add(values[i])        }      }        return differenceSet    }    //子集    this.subset = function(otherSet) {      if (this.size() > otherSet.size()) {        return false      } else {        var values = this.values()        for (var i = 0; i < values.length; i++) {          if (!otherSet.has(values[i])) {            return false          }        }        return true      }    }  }  ```  "
  },
  {
    "title": "javascript 实现队列",
    "path": "/Posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/javascript%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html",
    "strippedContent": " #### 什么是队列    队列是遵循 FIFO（First In First Out，先进先出，也称为先来先服务）原则的一组有序的项。 队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。    在计算机科学中，一个常见的例子就是打印队列。比如说我们需要打印五份文档。我们会打 开每个文档，然后点击打印按钮。每个文档都会被发送至打印队列。第一个发送到打印队列的文 档会首先被打印，以此类推，直到打印完所有文档    ```javascript  // 创建队列类方法  class Queue {    constructor() {      this.items = []    }    //相队列尾部添加一个元素    enqueue(element) {      this.items.push(element)    }    //移除队列的一个个元素    dequeue() {      return this.items.shift()    }    // 返回队列第一个元素,第一个被添加的元素    front() {      return this.items[0]    }    // 查看队列是否为空    isEmpty() {      return this.items.length == 0    }    // 清除队列    clear() {      this.items = []    }    // 返回队列包含的元素个数    size() {      return this.items.length    }    print() {      console.log(this.items.toString())    }  }  //测试用例  const queue = new Queue()  console.log(queue.isEmpty())  queue.enqueue('John')  queue.enqueue('Jack')  queue.print()  ```    #### 优先队列    队列大量应用在计算机科学以及我们的生活中，我们在之前话题中实现的默认队列也有一些 修改版本。  其中一个修改版就是优先队列。元素的添加和移除是基于优先级的。一个现实的例子就是机 场登机的顺序。头等舱和商务舱乘客的优先级要高于经济舱乘客。在有些国家，老年人和孕妇（或 带小孩的妇女）登机时也享有高于其他乘客的优先级。  另一个现实中的例子是医院的（急诊科）候诊室。医生会优先处理病情比较严重的患者。通 常，护士会鉴别分类，根据患者病情的严重程度放号。    实现一个优先队列，有两种选项：设置优先级，然后在正确的位置添加元素；或者用入列操 作添加元素，然后按照优先级移除它们。    ```JavaScript      function PriorityQuene() {        var items = []        //创建一个特殊的元素.包含优先级        function QueneElement(element, priority) {          this.element = element          this.priority = priority        }        // 入队方法        this.enquene = function (element, priority) {          // 实例化元素          var quemeElement = new QueneElement(element, priority)          // 如果队列是空的那么直接push          if (this.isEmpty()) {            this.push(quemeElement)          } else {            // 否则遍历队列中的元素比较优先级            var added = false            for (var i = 0; i < items.length; i++) {              // 如果新的元素优先级比更高那么在它前面push(1代表最高优先级              if (quemeElement.priority < items[i].priority) {                items.splice(i, 0, quemeElement)                added = true                break              }            }            // 如果没有找到更高的优先级那么自己push到后面            if(!added){              items.push(quemeElement)            }          }        }      }    ```    <script>  export default {    mounted() {      class Queue {        constructor() {          this.items = []        }        enqueue(element) {          this.items.push(element)        }        dequeue() {          return this.items.shift()        }        front() {          return this.items[0]        }        isEmpty() {          return this.items.length == 0        }        clear() {          this.items = [];        }        size() {          return this.items.length        }        print() {          console.log(this.items.toString())        }      }        var queue = new Queue();       console.log(queue.isEmpty());       queue.enqueue(\"John\");       queue.enqueue(\"Jack\");       queue.print();    },  }  </script>  "
  }
];